<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" href="/unofficial-desmos-wiki/css/base.css" />
    <title>Introduction To Per Pixel Rendering</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
    
<script src="https://www.desmos.com/api/v1.8/calculator.js?apiKey=dcb31709b452b1cf9dc26972add0fda6"></script>

<script defer>
window.addEventListener("load", () => {
  for (const e of document.getElementsByClassName("eleventy-desmos-mq-container")) {  
    const staticMath = Desmos.MathQuill.StaticMath(e);
    staticMath.latex(e.dataset.latex);
    e.querySelector(".dcg-mq-root-block").style.display = "inline";

    const settings = JSON.parse(e.dataset.settings);
    if (settings.copyButton) {
      const copyButton = document.createElement("button");
      copyButton.classList.toggle("eleventy-desmos-copy-button", true);
      copyButton.innerText = "Copy to Clipboard"
      e.parentElement.appendChild(copyButton);
      copyButton.onclick = () => {
        navigator.clipboard.writeText(e.dataset.latex);
        copyButton.innerText = "Copied!";
        setTimeout(() => {
          copyButton.innerHTML = "Copy to Clipboard";
        }, 750);
      }
    }
  }

  for (const e of document.getElementsByClassName("eleventy-desmos-dcg-container")) {
    const observer = new IntersectionObserver((entries, observer) => {
      if (!Array.from(entries).some(e => e.isIntersecting)) return;
      const Calc = Desmos.GraphingCalculator(e, JSON.parse(e.dataset.settings));
      Calc.setState(JSON.parse(e.dataset.state))
      observer.disconnect()
    });
    observer.observe(e, { threshold: 0.01 });
  }

})</script>
    
    <script src="/unofficial-desmos-wiki/pagefind/pagefind-ui.js"></script>
  </head>
  <body>
    <header class="header-side-by-side">
      <a href="/unofficial-desmos-wiki/">
        <div class="site-name">Desmos Wiki
          <span class="unofficial">(Unofficial)</span>
        </div>
      </a>
      <div id="searchbar"></div>
      <script>
        new PagefindUI({ element: "#searchbar"})
      </script>
      <button id="light-dark-toggle"></button>
    </header>
    <div class="main-content-side-by-side">
      <nav class="header-nav">
        <span class="header-nav-title">Introduction To Per Pixel Rendering</span>
        <ul><li><a href="#What's-the-difference">What's the difference?</a></li><li><a href="#Drawing-pixels">Drawing pixels</a><ul><li><a href="#Quick-aside:-Screen-space-coordinates">Quick aside: Screen space coordinates</a></li></ul></li><li><a href="#Drawing-better-pixels">Drawing better pixels</a></li><li><a href="#Drawing-on-the-screen">Drawing on the screen</a></li><li><a href="#Conclusion">Conclusion</a></li></ul>
      </nav>
      <main>
        <h1 data-weight="0">Introduction To Per Pixel Rendering</h1>
        <ul class="tags">
          
            <li class="tag">
              <a href="/unofficial-desmos-wiki/tag/guide/">guide</a>
            </li>
          
        </ul>
        
          <p>This article covers how to create and use a pixel grid in Desmos. Pixel grids are the foundation for many of the cool things you see people make with Desmos, such as fractals and raytracers. In the next article we will look at how to use a pixel grid to create a basic raytracer.</p>
<h2 id="What's-the-difference">What's the difference?<a class="link-to-header" href="#What's-the-difference"> #</a></h2>
<p>You may be asking, why would I want to do per pixel rendering, and how is it any different than rendering meshes using the <span class="dcg-calculator-api-container"><span class="eleventy-desmos-mq-container dcg-mq-math-mode" data-latex="polygon()" data-settings="{}"></span></span> function? <a href="../">Rendering using the polygon function</a> has one very significant limit: polygons must be a single colour, and most modern rendering methods require you to be able to modify not just the colour of every polygon in the scene, but every pixel on your screen. This is where per-pixel rendering comes in.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/3d/Phong-shading-sample_%28cropped%29.jpg" alt="A comparison of per-pixel and per-polygon rendering"></p>
<h2 id="Drawing-pixels">Drawing pixels<a class="link-to-header" href="#Drawing-pixels"> #</a></h2>
<p>Instead of having each polygon in our scene have its own colour, now we need to have each pixel on our screen have its own colour. Since we dont have any way to directly to do this with the calculator (without resorting to things like implicits), we will need to draw our own pixels. For now lets just try to generate a grid of points on the screen.</p>
<p>The easiest way to do it is with a nested list comprehension, if you are familiar with other programming languages this is equivalent to a nested for loop. Right now we will focus on generating a square, so the simplest way to do it is to chose some resolution you want, and then loop from -resolution to +resolution in both the x and y directions creating a point at each step. We'll also add a way to scale the screen, so that the higher the resolution the closer together the points will be to maintain a constant size. This can be done by multiplying the x and y coordinates by <span class="dcg-calculator-api-container"><span class="eleventy-desmos-mq-container dcg-mq-math-mode" data-latex="\frac{1}{\mathrm{resolution}}" data-settings="{}"></span></span>.</p>
<div class="eleventy-desmos-dcg-container" data-state="{&quot;version&quot;:9,&quot;randomSeed&quot;:&quot;&quot;,&quot;graph&quot;:{&quot;viewport&quot;:{&quot;xmin&quot;:-1.5,&quot;ymin&quot;:-1.5,&quot;xmax&quot;:1.5,&quot;ymax&quot;:1.5},&quot;squareAxes&quot;:true,&quot;xAxisLabel&quot;:&quot;&quot;,&quot;yAxisLabel&quot;:&quot;&quot;,&quot;xAxisArrowMode&quot;:&quot;NONE&quot;,&quot;yAxisArrowMode&quot;:&quot;NONE&quot;,&quot;xAxisMinorSubdivisions&quot;:0,&quot;yAxisMinorSubdivisions&quot;:0,&quot;xAxisStep&quot;:0,&quot;yAxisStep&quot;:0,&quot;degreeMode&quot;:false,&quot;showGrid&quot;:true,&quot;showXAxis&quot;:true,&quot;showYAxis&quot;:true,&quot;xAxisNumbers&quot;:true,&quot;yAxisNumbers&quot;:true,&quot;polarNumbers&quot;:true,&quot;restrictGridToFirstQuadrant&quot;:false,&quot;polarMode&quot;:false,&quot;userLockedViewport&quot;:true},&quot;expressions&quot;:{&quot;list&quot;:[{&quot;id&quot;:&quot;2&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#c74440&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;s_{ize}=10&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;animationPeriod&quot;:4000,&quot;loopMode&quot;:&quot;LOOP_FORWARD_REVERSE&quot;,&quot;playDirection&quot;:1,&quot;isPlaying&quot;:false,&quot;hardMin&quot;:true,&quot;min&quot;:&quot;1&quot;,&quot;hardMax&quot;:true,&quot;max&quot;:&quot;20&quot;,&quot;step&quot;:&quot;1&quot;},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;3&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#2d70b3&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;s_{cale}=\\frac{1}{s_{ize}}&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;4&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#2d70b3&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;\\left[\\left(x_{p},y_{p}\\right)\\cdot s_{cale}\\operatorname{for}x_{p}=\\left[-s_{ize}...s_{ize}\\right],y_{p}=\\left[-s_{ize}...s_{ize}\\right]\\right]&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}}]}}" data-settings="{}"></div>
<p>This works great, but there is a very obvious drawbacks to using points: they are circles. Circles cannot effectively tile a plane, so we end up with gaps in our grid.</p>
<h3 id="Quick-aside:-Screen-space-coordinates">Quick aside: Screen space coordinates<a class="link-to-header" href="#Quick-aside:-Screen-space-coordinates"> #</a></h3>
<p>Screen space coordinates are a coordinate system that is the same as the one we use to draw pixels. You may be familiar with some examples, for example if you have ever opened MS Paint and looked at the bottom left corner you will see the coordinates of your mouse. This is screen space coordinates. The x coordinate is the number of pixels from the left edge of the screen, and the y coordinate is the number of pixels from the top edge of the screen. This is the coordinate system we will be using to draw on the screen. In our case screen space coordinates will be in the range <span class="dcg-calculator-api-container"><span class="eleventy-desmos-mq-container dcg-mq-math-mode" data-latex="\left[-s_{ize}, s_{ize}\right]" data-settings="{}"></span></span> in both the x and y directions, and the origin will be in the center of the screen, ie equivalent to the regular coordinate system.</p>
<h2 id="Drawing-better-pixels">Drawing better pixels<a class="link-to-header" href="#Drawing-better-pixels"> #</a></h2>
<p>A much better option is something we already know: polygons. Using polygons we can make a square and place at every point on the screen and scaling it appropriately. We can create a list of points that represent a unit square, and then using another list comprehension we can place a square at every point on the screen. We can also use the same scaling trick as before to make sure that the squares stay roughly the same size no matter the resolution.</p>
<div class="eleventy-desmos-dcg-container" data-state="{&quot;version&quot;:9,&quot;randomSeed&quot;:&quot;&quot;,&quot;graph&quot;:{&quot;viewport&quot;:{&quot;xmin&quot;:-1.5,&quot;ymin&quot;:-1.5,&quot;xmax&quot;:1.5,&quot;ymax&quot;:1.5},&quot;squareAxes&quot;:true,&quot;xAxisLabel&quot;:&quot;&quot;,&quot;yAxisLabel&quot;:&quot;&quot;,&quot;xAxisArrowMode&quot;:&quot;NONE&quot;,&quot;yAxisArrowMode&quot;:&quot;NONE&quot;,&quot;xAxisMinorSubdivisions&quot;:0,&quot;yAxisMinorSubdivisions&quot;:0,&quot;xAxisStep&quot;:0,&quot;yAxisStep&quot;:0,&quot;degreeMode&quot;:false,&quot;showGrid&quot;:true,&quot;showXAxis&quot;:true,&quot;showYAxis&quot;:true,&quot;xAxisNumbers&quot;:true,&quot;yAxisNumbers&quot;:true,&quot;polarNumbers&quot;:true,&quot;restrictGridToFirstQuadrant&quot;:false,&quot;polarMode&quot;:false,&quot;userLockedViewport&quot;:true},&quot;expressions&quot;:{&quot;list&quot;:[{&quot;id&quot;:&quot;2&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#c74440&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;s_{ize}=10&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;animationPeriod&quot;:4000,&quot;loopMode&quot;:&quot;LOOP_FORWARD_REVERSE&quot;,&quot;playDirection&quot;:1,&quot;isPlaying&quot;:false,&quot;hardMin&quot;:true,&quot;min&quot;:&quot;1&quot;,&quot;hardMax&quot;:true,&quot;max&quot;:&quot;20&quot;,&quot;step&quot;:&quot;1&quot;},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;3&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#2d70b3&quot;,&quot;hidden&quot;:true,&quot;latex&quot;:&quot;g_{rid}=-\\left[\\left(x_{p},y_{p}\\right)\\cdot s_{cale}\\operatorname{for}x_{p}=\\left[-s_{ize}...s_{ize}\\right],y_{p}=\\left[-s_{ize}...s_{ize}\\right]\\right]&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;4&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#c74440&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;s_{cale}=\\frac{1}{s_{ize}}&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;5&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#2d70b3&quot;,&quot;hidden&quot;:true,&quot;latex&quot;:&quot;s_{quare}=\\left[\\left(1,1\\right),\\left(-1,1\\right),\\left(-1,-1\\right),\\left(1,-1\\right)\\right]\\cdot 0.5&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;6&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#2d70b3&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;\\left[\\operatorname{polygon}\\left(s_{cale}\\cdot s_{quare}+p_{os}\\right)\\operatorname{for}p_{os}=g_{rid}\\right]&quot;,&quot;lines&quot;:true,&quot;lineOpacity&quot;:&quot;0.9&quot;,&quot;lineWidth&quot;:&quot;2.5&quot;,&quot;lineStyle&quot;:&quot;SOLID&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}}]}}" data-settings="{}"></div>
<p>Great, now we have a grid of squares, but how do we actually address them?</p>
<h2 id="Drawing-on-the-screen">Drawing on the screen<a class="link-to-header" href="#Drawing-on-the-screen"> #</a></h2>
<p>Now that we actually have a grid, we still have to draw to them somehow, and the answer is: custom colours! We can use either the <span class="dcg-calculator-api-container"><span class="eleventy-desmos-mq-container dcg-mq-math-mode" data-latex="\operatorname{rgb}\left(\right)" data-settings="{}"></span></span> or <span class="dcg-calculator-api-container"><span class="eleventy-desmos-mq-container dcg-mq-math-mode" data-latex="\operatorname{hsv}\left(\right)" data-settings="{}"></span></span> functions to create a custom colour, and then assign that colour to our screen. By using the same list comprehension we used to create the grid to create we can create a way to <a href="/unofficial-desmos-wiki/list-manipulation/broadcasting/">broadcast</a> to every pixel on the screen.</p>
<p>As an example lets do something simple: a basic point light. First we'll create a point <span class="dcg-calculator-api-container"><span class="eleventy-desmos-mq-container dcg-mq-math-mode" data-latex="l_{ight}" data-settings="{}"></span></span> which will represent the position of some light in screen-space coordinates, and then for each pixel we will find the distance from it, and with that using the inverse square law we can calculate the brightness of the light at that point. We can then use that brightness to create a custom colour, and assign that colour to the pixel. To make it easier to see we will disable the lines of the polygons, and set the opacity to 1.</p>
<div class="dont-invert-colors">
<div class="eleventy-desmos-dcg-container" data-state="{&quot;version&quot;:9,&quot;randomSeed&quot;:&quot;&quot;,&quot;graph&quot;:{&quot;viewport&quot;:{&quot;xmin&quot;:-1.5,&quot;ymin&quot;:-1.5,&quot;xmax&quot;:1.5,&quot;ymax&quot;:1.5},&quot;squareAxes&quot;:true,&quot;xAxisLabel&quot;:&quot;&quot;,&quot;yAxisLabel&quot;:&quot;&quot;,&quot;xAxisArrowMode&quot;:&quot;NONE&quot;,&quot;yAxisArrowMode&quot;:&quot;NONE&quot;,&quot;xAxisMinorSubdivisions&quot;:0,&quot;yAxisMinorSubdivisions&quot;:0,&quot;xAxisStep&quot;:0,&quot;yAxisStep&quot;:0,&quot;degreeMode&quot;:false,&quot;showGrid&quot;:true,&quot;showXAxis&quot;:true,&quot;showYAxis&quot;:true,&quot;xAxisNumbers&quot;:true,&quot;yAxisNumbers&quot;:true,&quot;polarNumbers&quot;:true,&quot;restrictGridToFirstQuadrant&quot;:false,&quot;polarMode&quot;:false,&quot;userLockedViewport&quot;:true},&quot;expressions&quot;:{&quot;list&quot;:[{&quot;id&quot;:&quot;2&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#c74440&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;s_{ize}=10&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;animationPeriod&quot;:4000,&quot;loopMode&quot;:&quot;LOOP_FORWARD_REVERSE&quot;,&quot;playDirection&quot;:1,&quot;isPlaying&quot;:false,&quot;hardMin&quot;:true,&quot;min&quot;:&quot;1&quot;,&quot;hardMax&quot;:true,&quot;max&quot;:&quot;20&quot;,&quot;step&quot;:&quot;1&quot;},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;3&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#2d70b3&quot;,&quot;hidden&quot;:true,&quot;latex&quot;:&quot;g_{rid}=\\left[\\left(x_{p},y_{p}\\right)\\cdot s_{cale}\\operatorname{for}x_{p}=\\left[-s_{ize}...s_{ize}\\right],y_{p}=\\left[-s_{ize}...s_{ize}\\right]\\right]&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;4&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#c74440&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;s_{cale}=\\frac{1}{s_{ize}}&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;5&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#c74440&quot;,&quot;hidden&quot;:true,&quot;latex&quot;:&quot;s_{quare}=\\left[\\left(1,1\\right),\\left(-1,1\\right),\\left(-1,-1\\right),\\left(1,-1\\right)\\right]\\cdot 0.52&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;6&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#000000&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;l_{ight}=\\left(-0.006,0.027\\right)&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;7&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#6042a6&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;i_{ntensity}=0.1&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;animationPeriod&quot;:4000,&quot;loopMode&quot;:&quot;LOOP_FORWARD_REVERSE&quot;,&quot;playDirection&quot;:1,&quot;isPlaying&quot;:false,&quot;hardMin&quot;:true,&quot;min&quot;:&quot;0&quot;,&quot;hardMax&quot;:true,&quot;max&quot;:&quot;1&quot;},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;8&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#388c46&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;b_{rightness}=\\frac{1}{\\operatorname{distance}\\left(g_{rid},l_{ight}\\right)^{2}}&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;9&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#000000&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;C=\\operatorname{rgb}\\left(255\\cdot b_{rightness}\\cdot i_{ntensity},255\\cdot b_{rightness}\\cdot i_{ntensity},255\\cdot b_{rightness}\\cdot i_{ntensity}\\right)&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}},{&quot;id&quot;:&quot;10&quot;,&quot;secret&quot;:false,&quot;type&quot;:&quot;expression&quot;,&quot;color&quot;:&quot;#c74440&quot;,&quot;hidden&quot;:false,&quot;latex&quot;:&quot;\\left[\\operatorname{polygon}\\left(s_{cale}\\cdot s_{quare}+p_{os}\\right)\\operatorname{for}p_{os}=g_{rid}\\right]&quot;,&quot;colorLatex&quot;:&quot;C&quot;,&quot;lines&quot;:false,&quot;lineWidth&quot;:&quot;0&quot;,&quot;fill&quot;:true,&quot;fillOpacity&quot;:&quot;1&quot;,&quot;regressionParameters&quot;:{},&quot;slider&quot;:{&quot;hardMin&quot;:false,&quot;hardMax&quot;:false},&quot;displayEvaluationAsFraction&quot;:false,&quot;vizProps&quot;:{}}]}}" data-settings="{}"></div>
</div>
<p>This setup lets us simulate a point light shining onto a plane that we are looking directly onto.</p>
<p>If you notices the 0.52 instead of 0.5 on the square that is for seam filling, as we have disables polygon lines for performance reasons, we need to make sure that the squares are slightly larger than the grid so that there are no gaps between them.</p>
<h2 id="Conclusion">Conclusion<a class="link-to-header" href="#Conclusion"> #</a></h2>
<p>Now that you know how to make a basic pixel grid, you can use it to create more complex visuals.</p>

        
      </main>
    </div>
    <footer>
  <h2>Licensing</h2>
  <ul>
    <li>The source code that generates this site is licensed under the <a href="https://github.com/radian628/unofficial-desmos-wiki/blob/main/LICENSE.txt">MIT License</a>.</li>
    <li>All graphs and equations are licensed under <a href="https://creativecommons.org/public-domain/cc0/">CC0</a>, which essentially means "do whatever you want," so feel free to copy them to your own projects!</li>
    <li>The wiki articles themselves are licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a> so that the articles on this wiki may forever be free.</li>
  </ul>
</footer>
    <script>
      const ldt = document.getElementById("light-dark-toggle");

      let colorScheme = localStorage.getItem("color-scheme");

      if (!colorScheme) {
        localStorage.setItem("color-scheme", "light");
        let colorScheme = "light";
      }

      function setTheme() {
        const colorScheme = localStorage.getItem("color-scheme");

        document.body.classList.toggle("dark", colorScheme === "dark");

        ldt.innerText = colorScheme === "light" ? "â˜€ï¸" : "ðŸŒ™"
      }
      
      ldt.onclick = () => {
        localStorage.setItem("color-scheme", 
          localStorage.getItem("color-scheme") === "light" ? "dark" : "light")
        setTheme();
      }

      setTheme();
    </script>
  </body>
</html>